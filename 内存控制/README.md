# 内存控制

## 前言

很长一段时间内，JavaScript 开发者是无需关注内存控制的，主要是因为在短时间运行的页面中，内存的问题并不经常出现，用户在访问一段时间后就会离开页面了。

但当 JavaScript 进入服务器领域，情况就不同了，服务器是一个长时间运行的环境，开发者需要加强对 Node.js 内存管理的意识，并掌握一些常用的技巧。毕竟，在服务器端，资源是有限的。

## V8 的垃圾回收机制与内存限制

JavaScript 和 Java 一样，由垃圾回收机制来进行自动内存管理。

对于性能敏感的服务器端程序，内存管理的好坏、垃圾回收状况是否优良，都会对服务构成影响。这一切都与 Node 的 JavaScript 执行引擎 V8 息息相关。

+   Node 与 V8

    V8 是 Google Chrome 的 JavaScript 引擎，其在 N 年前的浏览器大战中，帮助 Chrome 胜出，其性能优势使得 JavaScript 写高性能后台服务成为可能。

    在这样的契机下，Node.js 的创始人选择了 JavaScript 和 V8，在事件驱动、非阻塞I/O模型的设计下实现了 Node。

+   V8 的内存限制

    在一般的后端开发语言中，在基本的内存使用上并没有什么限制，但是在 Node 中通过 JavaScript 使用内存时却只能使用部分内存（64 位系统下约 1.4GB，32 位系统下约 0.7GB）。

    这样的限制下，导致 Node 无法**直接操作**大内存对象。比如一个 2GB 的文件在 Node 中是无法读入内存进行字符串分析处理的，即使物理内存有 32GB。

    这样，在**单个 Node 进程**的情况下，计算机的内存资源无法得到充足的使用。

    原因是 Node 基于 V8 构建，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。

    V8 为什么要限制内存使用大小，表层原因是 V8 最初为浏览器设计，不太可能遇到大量内存的场景。深层原因是 V8 的垃圾回收机制的限制。

    按照官方的说法，以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50ms 以上，做一次非增量式的垃圾回收甚至要 1s 以上。这是垃圾回收中引起 JavaScript 线程暂停执行的时间。这样，应用的性能和响应能力都会直线下降。

    V8 的这套内存管理机制在浏览器端是绰绰有余的，但在 Node 中，却限制了开发者随心所欲使用大内存的想法。

    好在，服务器端操作大内存并不是常见的需求场景，另外，我们也有一些手段解决这个问题。

+   V8 的对象分配

    V8 中所有的 JavaScript 对象都是通过堆来进行分配的。

    Node 提供了 V8 中内存使用量的查看方式：

    ```
    $ node >
    > process.memoryUsage()
    ```

    输出

    ```
    {
        rss: 22114304,
        heapTotal: 7708672, // 已申请到的堆内存
        heapUsed: 4954016, // 当前使用的堆内存
        external: 8782
    }
    ```

    当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8 的限制为止。

    当然，V8 的限制也可以打开，方式就是：

    ```
    node --max-old-space-size=1700 testjs // 单位为 MB
    或者
    node --max-new-space-size=1024 testjs // 单位为 KB
    ```

+   V8 的垃圾回收机制

    这块比较繁杂，先跳过吧...

## 高效实用内存

## 参考

+   《深入浅出 Node.js》