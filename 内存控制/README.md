# 内存控制

## 前言

很长一段时间内，JavaScript 开发者是无需关注内存控制的，主要是因为在短时间运行的页面中，内存的问题并不经常出现，用户在访问一段时间后就会离开页面了。

但当 JavaScript 进入服务器领域，情况就不同了，服务器是一个长时间运行的环境，开发者需要加强对 Node.js 内存管理的意识，并掌握一些常用的技巧。毕竟，在服务器端，资源是有限的。

## V8 的垃圾回收机制与内存限制

JavaScript 和 Java 一样，由垃圾回收机制来进行自动内存管理。

对于性能敏感的服务器端程序，内存管理的好坏、垃圾回收状况是否优良，都会对服务构成影响。这一切都与 Node 的 JavaScript 执行引擎 V8 息息相关。

+   Node 与 V8

    V8 是 Google Chrome 的 JavaScript 引擎，其在 N 年前的浏览器大战中，帮助 Chrome 胜出，其性能优势使得 JavaScript 写高性能后台服务成为可能。

    在这样的契机下，Node.js 的创始人选择了 JavaScript 和 V8，在事件驱动、非阻塞I/O模型的设计下实现了 Node。

+   V8 的内存限制

    在一般的后端开发语言中，在基本的内存使用上并没有什么限制，但是在 Node 中通过 JavaScript 使用内存时却只能使用部分内存（64 位系统下约 1.4GB，32 位系统下约 0.7GB）。

    这样的限制下，导致 Node 无法**直接操作**大内存对象。比如一个 2GB 的文件在 Node 中是无法读入内存进行字符串分析处理的，即使物理内存有 32GB。

    这样，在**单个 Node 进程**的情况下，计算机的内存资源无法得到充足的使用。

    原因是 Node 基于 V8 构建，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。

    V8 为什么要限制内存使用大小，表层原因是 V8 最初为浏览器设计，不太可能遇到大量内存的场景。深层原因是 V8 的垃圾回收机制的限制。

    按照官方的说法，以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50ms 以上，做一次非增量式的垃圾回收甚至要 1s 以上。这是垃圾回收中引起 JavaScript 线程暂停执行的时间。这样，应用的性能和响应能力都会直线下降。

    V8 的这套内存管理机制在浏览器端是绰绰有余的，但在 Node 中，却限制了开发者随心所欲使用大内存的想法。

    好在，服务器端操作大内存并不是常见的需求场景，另外，我们也有一些手段解决这个问题。

+   V8 的对象分配

    V8 中所有的 JavaScript 对象都是通过堆来进行分配的。

    Node 提供了 V8 中内存使用量的查看方式：

    ```
    $ node >
    > process.memoryUsage()
    ```

    输出

    ```
    {
        rss: 22114304,
        heapTotal: 7708672, // 已申请到的堆内存
        heapUsed: 4954016, // 当前使用的堆内存
        external: 8782
    }
    ```

    当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8 的限制为止。

    当然，V8 的限制也可以打开，方式就是：

    ```
    node --max-old-space-size=1700 testjs // 单位为 MB
    或者
    node --max-new-space-size=1024 testjs // 单位为 KB
    ```

+   V8 的垃圾回收机制

    这块比较繁杂，先跳过吧...

## 背景知识

+   作用域链

    简单来说，JavaScript 中变量的查找是遵循一个链条的：

    ```
    当前执行环境 --> 所在方法定义的环境 --> ... --> 顶级对象
    ```

+   闭包

    函数在执行的时候，都会临时创建一个活动对象，函数执行结束后，该活动对象会被销毁，这样便于优化性能，而且是自动化的。

    但是，如果有其他环境的变量 A 引用了活动对象中的变量，并且变量 A 并没有销毁，那么，活动对象就不会被销毁。

    闭包是会占用内存的，如果一直存在并不断新增各种闭包，那么内存使用会不断增长。

## 查看内存

TODO...

## 内存泄露

Node 对内存泄露十分敏感，一旦线上应用有成千上万的流量，哪怕是一个字节的内存泄露，也会造成堆积。

垃圾回收过程中，会耗费更多的时间进行对象扫描，应用响应缓慢，直到内存溢出，应用崩溃。

在 V8 的垃圾回收机制下，在通常的代码编写中很少会出现内存泄露的情况。但内存泄露通常产生于无意间，很难排查。

虽然内存泄露的情况不尽相同，但其实质只有一个，就是应当回收的对象出现意外没有被回收。

通常，造成内存泄露的原因有如下几个：

+   缓存
+   队列消费不及时
+   作用域未释放

下面逐一解释。

### 缓存造成的内存泄露

**慎将内存当做缓存**。

缓存在应用中可以十分有效地节省资源，它的访问效率要比 I/O 的效率高，一旦命中缓存，就可以节省一次 I/O 的时间。

但是在 Node 中，缓存是把双刃剑。

一旦一个对象被当做缓存使用，那就意味着它将常驻内存不会销毁，长期存活的对象越来越多，将导致垃圾回收在进行扫描和整理时，对这些对象做无用功。

JavaScript 开发者可以很方便地用对象的键值对来缓存东西，但，**严格意义上的缓存有完善的过期策略**，而普通对象的键值对并没有。

+   限制缓存键值数量

    我们可以通过限制缓存对象键值的数量，先进先出的方式来避免缓存导致的内存泄露。

    可以参考 Issac Z. Schlueter 采用 LRU 算法的缓存模块（node-lru-cache）

+   模块提供清除队列的接口

    node 的模块机制，导致模块被引用后，通过模块提供的接口来访问模块内部的变量，并且模块有缓存机制，所以在设计模块时，要十分小心内存泄露的出现。

    如果模块不可避免地要访问内部变量，那么请添加清空队列的接口，以供调用者释放内存。

+   实际解决方案

    进程间是无法共享内存的，如果在进程内使用缓存，这些缓存不可避免地有重复，对内存是种浪费。

    目前比较好的使用大量缓存的方案是采用进程外的缓存，进程自身不存储状态。

    外部的缓存软件有良好的缓存过期淘汰策略和自有的内存管理，不影响 Node 的性能。

    常见的有 `Redis`、`Memcached` 等。

### 关注队列状态

队列产生的内存泄露通常是不经意的，这个经常被忽略。

举个例子，如果通过数据库来记录日志，由于数据库写入相对于其他 I/O 速度是较慢的，一旦有海量的日志写入需求，数据库写入造成了堆积，队列没有被清空，会导致内存一直上涨。

解决方案一，是采用消费速度更高的技术，比如在日志收集的案例中，使用文件写入日志的方式更高效，但不能根本解决问题。

解决方案二，是监控队列的长度，一旦堆积，通过监控系统报警并通知相关人员。

解决方案三，是任何一部调用都应该包含超时机制，一旦在限定时间内没有完成响应，通过回调函数传递超时异常，使每个异步调用具备可控的响应，及时清除内存占用。

## 内存泄露排查

todo...

## 大内存应用

如果不可避免地需要操作大文件，由于 Node 的内存限制，操作大文件需要小心，Node 专门为这种情况，提供了 stream 模块用于处理大文件。

stream 模块是 Node 的原生模块，它继承自 EventEmitter，Node 中大多数模块都有 stream 的应用，如 `fs` 的 `createReadStream()` 和 `fs.createWriteStream()`、`process` 模块的 `stdin` 和 `stdout`等。

比如：

```js
const reader = fs.createReadStream('in.txt');
const writer = fs.createWriteStream('out.txt');

reader.pipe(writer);
```

## 参考

+   《深入浅出 Node.js》